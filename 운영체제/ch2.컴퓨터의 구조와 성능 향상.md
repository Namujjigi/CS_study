## Ch2. 컴퓨터의 구조와 성능 향상

- 컴퓨터를 구성하는 하드웨어 특성 이해
- CPU와 메모리의 구성 및 동작 방식 이해
- 컴퓨터 성능을 향상하는 기술 학습
- 병렬 처리의 개념 이해 및 기법 학습



### 컴퓨터의 기본 구성

- 하드웨어의 구성
  - 필수장치
    - 중앙처리장치 `CPU`(제1저장장치), 메인메모리 `메모리`
    - CPU : 명령어를 해석하여 실행하는 장치
    - 메모리 : 작업에 필요한 프로그램과 데이터를 저장하는 장소, 바이트 단위로 분할되어 있으며 분할 공간마다 주소로 구분
  - 주변장치
    - 입력장치, 출력장치, 저장장치(보조 저장 장치, 제2저장장치) 
    - 입력장치 : 마우스, 키보드, 터치스크린 등
    - 출력장치 : 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력하는 장치
      - 참고 : GPU(graphical processing unit) 그래픽 카드에 직접 달아 계산을 직접처리(cpu가 아니라)
    - 저장장치 : 메모리보다 느리지만, 용량에 비해 저렴하고 영구적으로 데이터 저장가능
      - 자성을 이용 : 플로피 디스크, 하드 디스크
      - 레이저를 이용 : CD, DVD, 블루레이디스크
      - 메모리를 이용 : USB, SD카드, CF카드, SSD
    - 메인보드 : 각 장치를 연결하는 선의 집합이자 데이터가 지나다니는 통로, CPU와 메모리 등 다양한 부품을 연결하는 판

- 폰노이만 구조
  - CPU, 메모리, 입출력장치, 저장장치가 연결된 구조
  - 메모리를 이용하여 프로그래밍이 가능한 컴퓨터 구조
  - 하드웨어는 그대로 둔 채 작업을 위한 프로그램만 교체하여 메모리에 올리는 방식
  - 모든 프로그램은 메모리에 올라와야 실행 가능
- 하드웨어 사양 관련 용어
  - 클럭(clock) : CPU속도와 관련된 단위
    - CPU가 작업할 때 일정한 박자를 만들어내는 것
    - 클럭이 일정한 간격으로 틱(tick, pulse, clock tick)을 만들면 거기에 맞추어 CPU안의 모든 구성 부품이 작업
    - 메인보드의 클록이 틱을 보낼 때마다 데이터를 보내거나 받는다
  - 헤르츠
    - 클럭틱이 발생하는 속도를 나타내는 단위
    - 1초에 1번 발생하는걸 `Hz`
  - 시스템 버스와 CPU내부 버스
    - 시스템 버스(system bus) : 메모리와 주변장치를 연결하는 버스
      - FSB(front-side bus, 전면버스)
      - 메인보드와 메모리의 `Hz`를 맞춰야함 어느한쪽이 떨어지면 성능저하
    - CPU내부버스 : CPU 내부에 있는 장치를 연결하는 버스
      - BSB(back-side bus, 후면버스)
      - CPU내부 버스의 속도는 CPU클록과 같아서 시스템 버스보다 훨씬 빠름
    - CPU는 CPU내부 버스의 속도로 작동/ 메모리는 시스템 버스의 속도로 작동 => 작업이 지연되는 문제가 발생(3절에서 해결)



### CPU와 메모리

- CPU의 구성과 동작

  - 기본구성 : 산술논리 연산장치, 제어장치, 레지스터

    - 산술논리 연산장치 : 데이터를 연산하는 장치(덧셈, 뺄셈, 곱셈, 나눗셈 / 산술장치)(And, Or / 논리연산)
    - 제어장치 : 작업을 지시하는 부분
    - 레지스터 : 데이터를 임시로 보관하는 곳

  - 처리과정

    ```C
    int D2=2, D3=3, sum;
    sum=D2+D3;
    ```

    - D2, D3, sum => 데이터를 저장할 수 있는 메모리 주소의 다른 이름을 붙인 것
    - 이 코드를 컴파일러를 통해 기계어로 바꿈 => 2진수로 이루어진 기계어 => CPU가 알아듣고 연산
    - CPU가 연산을 하기 위해선 필요한 데이터를 CPU로 가져와 임시로 보관해야 하는데, 이 장소가 레지스터
    - 제어장치는 명령어를 해석하여 제어 신호를 보내고 CPU 내의 데이터 흐름을 조절하는 역할

  - 레지스터 종류

    - 사용자 가시 레지스터 : 사용자 프로그램에 의해 변경
      - 데이터레지스터 : 메모리에서 가져온 데이터를 임시로 보관할 때 사용
      - 주소레지스터 : 데이터 또는 명령어가 저장된 메모리의 주소 저장
    - 사용자 불가시 레지스터 : 사용자가 임의로 변경 불가능
      - 프로그램 카운터 : 다음에 실행할 명령어의 주소를 가르킴
      - 명령어 레지스터 : 현재 실행 중인 명령어를 저장
      - 메모리 주소 레지스터 : 메모리에 데이터를 가져오거나, 보낼 때 주소를 지정하기 위해 사용
      - 메모리 버퍼 레지스터 : 메모리에서 가져온 데이터나 메모리로 옮겨 갈 데이터를 임시 저장(메모리 주소 레지스터와 함께 작동)
      - 프로그램 상태 레지스터 : 연산 결과(음수, 양수 등)을 저장(ex. if문 처리)

  - 버스의 종류

    - 제어 버스 
      - 다음에 어떤 작업을 할지 지시하는 제어신호가 오감
      - 메모리에서 데이터를 가져올 때 읽기 신호, 처리한 데이터를 메모리로 옮겨놓을 때 쓰기 신호
      - 제어 버스의 신호는 CPU, 메모리, 주변장치와 양방향
    - 주소 버스
      - 메모리의 데이터를 읽거나 쓸 때 어느 위치에서 작업할 것인지 알려주는 위치 정보(주소)가 오감
      - 메모리 주소 레지스터와 연결되어 있으며 단방향
      - CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만 주소 버스를 통해 CPU로 전달되는 정보는 없음
    - 데이터 버스
      - 메모리 버퍼 레지스터와 연결되어 있으며 양방향
      - 어떤 작업을 할지 + 어디에 할지 정보를 가지고 목적지까지 전달 역할
      - 참고 : 버스의 대역폭이란?
        - 한 번에 전달할 수 잇는 데이터의 최대 크기
        - CPU가 한 번에 처리할 수 있는 데이터 크기와 동일
        - 한 번에 처리될 수 있는 데이터의 최대 크기를 `워드`라고 함
        - 32bit CPU에서 1워드는 32bit

- 메모리의 종류와 부팅

  - 메모리의 종류
    - RAM(Random Access Memory) : 읽고 쓰기 가능
      - 휘발성 메모리
        - DRAM(Dynamic RAM, 동적 램)
          - 저장된 0과 1의 데이터가 일정 시간이 지나면 사라지므로 일정 시간마다 다시 재생 필요
          - 일반적으로 메인메모리
        - SRAM(Static RAM, 정적 램)
          - 전력이 공급되는 동안에는 데이터를 보관할 수 있어 재생 불필요
          - 빠른 속도와 비싼 가격
          - 캐시와 같은 고속 메모리
        - SDRAM(Synchronous Dynamic Random Access Memory)
          - DRAM의 발전형태로 SRAM과 완전히 다름
          - 클럭틱이 발생할 때마다 데이터를 저장하는 동기 DRAM
      - 비휘발성 메모리
        - 플래시 메모리
          - 디지털 카메라, MP3 플레이어, USB 드라이버와 같은 저장장치로 많이 사용
          - 각 소자의 최대 사용횟수가 제한되어 주의 필요
        - FRAM(Ferroelectric RAM)
        - PRAM(Phase change RAM)
    - ROM(Read Only Memory) : 읽기만 가능
      - 마스크 롬 : 데이터를 지우거나 쓸 수 없음
      - PROM(Programmable ROM) : 전용 기계를 이용하여 데이터를 한 번만 저장 가능
      - EPROM(Erasable Programmable ROM) : 데이터를 여러 번 쓰고 지울 수 있음(플래시 메모리 처럼 활용 가능하지만 비싸서 안씀)
  - 메모리 보호
    - 일괄 작업 시스템(일괄 처리 시스템)에서는 메모리가 운영체제 영역과 사용자 영역으로 구분 됨
    - 이 때, 사용자 영역의 작업이 운영체제 영역으로 침범하지 못하도록 막는 것이 메모리 보호
    - 시분할 기법으로 사용하여 여러 프로그램을 동시에 실행 => 그만큼 사용자 영역이 많아짐 => 메모리 보호는 중요한 문제
    - 보호가 되지 않는다면 다른 작업에 침범하고 -> 시스템이 멈출 수 있음 -> 이런 녀석들이 악성 소프트웨어(바이러스)
    - 운영체제 역시 소프트웨어 -> 사용자의 작업이 진행되는 동안(사용자 프로세스가 CPU를 차지하는 동안) 운영체제의 작업이 잠시 중단 -> 이 때 메모리를 보호하기 위해 하드웨어의 도움이 필요
    - 구체적인 과정
      - CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터(bound register)에 저장한 후 작업
      - 현재 진행 중인 작업이 차지하고 있는 메모리의 크기(마지막 주소 까지의 차이를) 한계 레지스터(limit register)에 저장
      - 사용자의 작업이 이 두 레지스터의 주소 범위를 벗어나는지 하드웨어적으로 점검 -> 메모리 보호
      - 만약 두 레지스터의 값을 벗어 난다면 메모리 오류와 관련된 인터럽트가 발생 -> CPU가 운영체제를 깨워서 해결
      - 메모리 영역을 벗어나서 발생한 인터럽트의 경우 운영체제가 해당 프로그램을 강제 종료
  - 부팅
    - CPU에 의해 실행되는 모든 프로그램은 메모리에 올라와야 실행이 가능
    - 근데, 응응 프로그램은 운영체제가 메모리에 올리는데, 그럼 운영체제는 메모리에 누가 올리나...?
    - 운영체제를 메모리에 올리는 과정을 부팅이라고 한다
    - 대충 정리하자면
      - 컴퓨터를 킬 때 하드웨어적인 문제를 확인하고
      - 문제가 없다면 하드디스크의 마스터 부트 레코드에 저장된 작은 프로그램을 메모리로 가져와 실행
      - 부트스트랩(운영체제를 실행하기 위한 코드, 마스터 부트 레코드에 저장되어있음) -> 운영체제를 메모리에 가져와 실행



### 컴퓨터 성능 향상 기술

- 시스템 버스와 CPU내부 버스의 속도가 다름
- CPU 내부 버스의 속도가 더 빨라서 시스템 버스가 못 따라감
- 장치간 속도를 개선할 필요가 있음



- 버퍼
  - 개념 : 일정량의 데이터를 모아 옮김으로써 속도의 차이를 완화하는 장치
    - 속도에 차이가 있는 두 장치 사이에서 그 차이를 완화하는 역할을 함
    - 느린 입출력 장치에서 데이터를 읽을 때마다 하나씩 전송하면 작업량에 비해 실제로 전송되는 데이터 양은 작음
    - 그래서 일정량의 데이터를 모아 한꺼번에 전송
  - 스풀 : CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼 (예시, 프린터의 스풀러)
- **캐시(cache)**
  - 메모리와  CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 장소
  - 미리가져오기(prefetch) : CPU가 사용할 것으로 예상되는 데이터를 미리 가져다 놓는 작업
  - 필요하다고 생각되는 일정량의 데이터를 미리 가져와 저장해두는 곳
  - 즉시쓰기와 지연쓰기 : 캐시에 있는 데이터가 변경 됐을 때 메모리에 있는 원래 데이터를 변경하기 위한 방법
    - 즉시쓰기 : 캐시에 있는 데이터가 변경되면 이를 즉시 메모리에 반영하는 방식
      - 메모리와의 빈번한 데이터 전송으로 인해 성능이 느려짐
      - 메모리의 최신 값이 항상 유지되기 때문에 급작스러운 정전에도 데이터를 잃어버리지 않음
    - 지연쓰기 : 카피백/ 변경된 내용을 모아서 주기적으로 반영
      - 메모리와 데이터 전송 횟수가 줄어들어 시스템의 성능을 향상할 수 있음
      - 메모리와 캐시된 데이터 사이의 불일치 발생 가능성
  - L1캐시와 L2캐시
    - 프로그램의 명령어는 어떤 작업을 할지 나타내는 `명령어` 부분과 작업 대상인 `데이터 부분`으로 구성
    - 일반캐시 : 명령어와 데이터를 구분하지 않음
    - 특수캐시 : 명령어와 데이터를 구분
    - 특수캐시는 CPU레지스터에 직접 연결되어 있음, 일반 캐시는 메모리와 연결됨
    - 특수캐시 = L1, 일반캐시 = L2
- 저장장치의 계층구조
  - CPU에 가까울 수록 빠르다(레지스터 > 캐시 > 메모리 > 저장장치)
- 인터럽트
  - 과거 폴링(pooling) 방식의 경우 CPU가 직접 입출력장치에서 데이터를 가져오거나 내보냈음 => 작업효율 저하
  - 현재 컴퓨터는 주변장치가 많기 때문에 인터럽트(interrupt) 방식을 기용
  - 인터럽트 방식 : CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영하여 효율 증가
  - 인터럽트 방식의 동작 과정
    - CPU가 입출력 관리자에게 입출력 명령을 보냄
    - 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장장치로 옮김
    - 데이터 전송이 완료되면 입출력 관리자는 완료신호를 CPU로 보냄 => 이 신호를 인터럽트라고 함
    - CPU는 인터럽트에 따라 일을 중단하고 옮겨진 데이터를 처리
    - 인터럽트 번호 : 어떤 주변장치에서 완료신호를 보냈는지 구분하기 위한 구분자
  - CPU는 여러 개의 입출력 작업을 동시에 시키기 위해 인터럽트 벡터를 사용
    - 인터럽트 벡터 : 여러개의 인터럽트를 하나의 배열로 만든 것
  - 직접 메모리 접근
    - 입출력 관리자가 메모리의 접근을 하기위해 CPU로부터 받는 권한
  - 메모리 매핑 입출력
    - 직접 메모리 접근을 사용하면 CPU가 사용하는 데이터와 입출력 장치가 사용하는 데이터가 섞여 복잡해짐
    - 이것을 막기 위해 CPU가 사용하는 메모리 공간과/ 직접 메모리 접근을 통해 들어오거나 나가는 데이터를 위한 공간을 분리
  - 사이클 훔치기
    - 직접 메모리 접근을 통해 입출력장치도 메모리 사용이 가능 => 그럼 CPU와 동시에 접근했을 때는?? => 사이클 훔치기를 통해 직접 메모리 접근이 메모리 사용 권한을 CPU로 부터 먼저 받아옴(직접 메모리 접근이 더 느리니까)
- 병렬처리
  - CPU의 성능을 향상시키는 가장 간단한 방법은 CPU의 클록을 높이거나 캐시의 크기를 늘리는 것
  - CPU클록을 높이면 => 발열문제
  - 캐시의 크기 늘리기 => 비용문제
  - CPU의 성능 향상을 위해 CPU 핵심 기능을 가진 코어를 여러개 만드러간, 동시에 실행 가능한 명령의 개수를 늘리는 방법 사용
  - 병렬처리 : 동시에 여러개의 명령을 처리하여 작업의 능률을 올리는 방식
