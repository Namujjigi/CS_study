## 운영체제와 컴퓨터

2일에 한챕터 가고 => 복습하고 => 리뷰퀘스천 같이 한번보고



1/18(화)

- 운영체제란 무엇인가?? => 유저와 컴퓨터 하드웨어 간에 바로 작동할 수 있게 해주는 프로그램
  - 초기에 컴퓨터는 애니악?? => 미사일탄도만 구하면됐음 그래서 업뎃도 필요없고, 그냥 시키는것만 하면됐는데 => 현재 컴퓨터는 기능도 다양하고 엄청 커졌잖아?? => 이거를 효율적으로 관리할 수 있는 사용규칙이 필요하다 => 이걸 운영체제를 통해서 실현함
- 운영체제의 역할 : 지속적으로 업데이트를 할 수 있음 (1. 자원관리 2. 자원보호 3. 인터페이스제공)
  - ex) 운영체제가 없는 기기면 초창기에 설계한것만 할 수 잇는데 <-> 운영체제가 있다면 업데이트를 통해서 새 기능을 추가할 수 있음 => `programmable machine`
  - 컴퓨터 자원관리 역할 
    - ex) 크롬틀고, 파이참키고, ppt키고 => 중재자역할
  - 컴퓨터 자원을 보호해줌 => 인터페이스를 제공해줌으로써 자원보호 + 사용자 편의 도모
    - 사용자가 만약에 하드디스크에 직접 뭔가 저장하고 삭제하고 -> 악용의 여지가 생긴다

- 현업자 친구들 피셜
  - No universally accepted definition
  - 이제는 경계가 굉장히 모호하다
  - 운영체제라고하면 Mac, 윈도우, linux 겁나 다양한데 -> 운영체제를 또 운영하기위한 그런 체제도있고
  - 키보드랑 - 컴퓨터랑 연결해주는 운영체제가있는데 그걸 또 프로그램으로 쓰려고하면 다른 운영체제도 개입하고 



## 운영체제의 정의 및 역할

- 정의 : 사용자에게 편리한 인터페이스 호나경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어
- 역할
  - 자원관리 : 컴퓨터 자원을 응용프로그램에 적절히 나누어줌
  - 자원보호 
  - 하드웨어 인터페이스 제공 : 다양한 하드웨어를 일관된 방법으로 사용(장치 드라이버 = 하드웨어 인터페이스)
  - 사용자 인터페이스 제공(GUI)

- 목표
  - 효율성
    - 같은 자원 더 많은 일 처리/ 같은 작업량 적은 시간
  - 안정성
    - 응용 프로그램의 안전 문제
    - 하드웨어적 보안 문제
    - 결함 포용 기능(문제 발생 시 이전으로 복구)
  - 확장성
    - 플러그 앤드 플레이
  - 편리성
    - 편리성을 제공하지 않으면(GUI 등) 효율은 높아지지만 그러면 안됨



## 운영체제의 역사

- 개요
  - 1940년대 : /진공관 사용
  - 1950년대 : 카드 리더, 라인 프린터 / 일괄 작업 시스템, 운영체제의 등장
  - 1960년대 초 : 키보드, 모니터 / 대화형 시스템
  - 1960년대 후 : C언어 / 다중 프로그래밍 기술 개발, 시분할 시스템
  - 1970년대 : PC / 개인용 컴퓨터, 분산 시스템
  - 1990년대 : 웹 / 클라이언트, 서버시스템
  - 2000년대 : 스마트폰 / P2P 시스템, 그리드 컴퓨팅, 클라우드 컴퓨팅, 사물 인터넷



- 초창기 컴퓨터(1940)
  - 애니악
  - 전선을 잭에 꼽아 회로를 연결하여 구성
  - 미사일 탄도 계산 목적
  - 주변장치가 없었음(모니터, 마우스, 키보드 등)
  - 진공관을 전선으로 연결한 것이 프로그램을 대신함
  - 하드와이어링 방식 : 전선을 연결하여 논리회로를 구성 => 만약 다른 계산을 하려면 전선을 다시 연결해야함

- 일괄 작업 시스템(1950)
  - IC칩(Integrated Circuit) : 진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 구현 -> 현대 컴퓨터의 시초
  - 중앙처리장치(메인메모리, CPU)는 존재, 입력장치(키보드)와 출력장치는 없었음(모니터)
  - 천공카드 리드를 입력장치, 라인 프린터를 출력장치로 사용
  - 천공카드 리더를 통한 프로그래밍 가능
  - 일괄작업 시스템(일괄처리 시스템) : 모든 작업을 한꺼번에 처리해야 하고, 프로그램 실행 중간에 데이터 입력 및 수정 불가능
- 대화형 시스템(1960 초)
  - 키보드와 모니터 등장 => 작업 중간에 사용자가 입력을 하거나 사용자에게 중간 결과값을 보여줄 수 있게됨
    - 일괄작업 시스템에서는 최종 결과만 볼 수 있고, 그 값을 바탕으로 천공카드를 새로 뚫어서 프로그래밍을 했었음
  - 진행 도중에 사용자로부터 입력을 받을 수 있고, 그 값에 따라 작업의 흐름을 바꾸는 것이 가능 => 대화형 시스템
  - 작업 시간 예측이 어려워짐 => 입력과 출력이 얼마만에 완료될지 예측하기 어렵고, 사용자의 반응시간 고려 불가능
- 시분할 시스템(1960 후)
  - 다중 프로그래밍 기술 : 하나의 CPU로 여러 작업을 동시에 실행하는 기술, 일괄 작업에 비해 효율적
  - 시간 분할을 통해 다중 프로그래밍을 구현
    - 시스템에서 CPU 사용 시간을 아주 잘게 쪼개어 여러 작업에 나누어 줌
    - 이때 잘게 나누니 시간 한 조각을 타임 슬라이스(타임 퀀텀)이라고 함
  - 여러 작업을 동시에 처리하기 위한 추가 작업이 필요한 것이 단점
    - 그래서 중요한 작업의 경우(미사일 제어, 원자력 제어 등) 실시간 시스템을 사용
    - 실시간 시스템 : 특정 시스템에서 일정 시간 안에 작업이 처리되도록 보장하는 것
  - 다중 사용자 시스템 : 한 사람이 여러개의 작업을 할 수 있다 = 여러 사람이 동시에 작업할 수 있다.
    - C언어로 개발된 유닉스 : 멀티프로그래밍과 다중 사용자를 지원하는 운영체제
- 분산 시스템(1970)
  - 개인용 컴퓨터의 등장 : 스티브 잡스가 최초로 발표
    - 운영체제로 매킨토시와 MS-DOS가 널리 사용됨
  - 서로 호환되지 않는 LAN(local area network)들을 하나로 묶어 ARPAnet을 제작
  - TCP/IP  정의
  - 분산 시스템 : 작은 컴퓨터를 여러대 묶어 대형 컴퓨터의 기능에 버금가는 시스템을 만든 것
    - 네트워크상에 분산되어 있는 여러 컴퓨터로 작업을 처리하고 그 결과를 상호 교환하도록 구성한 시스템
- 클라이언트/서버 시스템(1990~현재)
  - 분산 시스템의 문제 : 참가하는 모든 컴퓨터가 동일한 지위이기 때문에 컴퓨터가 고장나거나 추가되면 작업을 분배하고 결과를 모으기 어려움
  - 클라이언트/서버 시스템 : 작업을 요청하는 클라이언트와 거기에 응답하여 요청받은 작업을 처리하는 서버의 이중구조
    - 서버 과부하가 문제
- P2P 시스템(2000~현재)
  - P2P(peer-to-peer) : 서버 과부하를 해결하기위한 시스템
    - peer는 말단 노드, 사용자의 컴퓨터를 가르킨다
    - P2P는 서버를 거치지 않고 사용자와 사용자를 직접 연결한다는 의미
    - 시스템에서 파일 검색만 담당 => 사용자간 파일 전송
  - 메신저, 파일공유 등
- 기타 컴퓨팅 환경(2000 ~ 현재)
  - 여기는 제가 이해를 잘 못하겠슴다.. 그냥 그런게 있데요
  - 그리드 컴퓨팅
  - 클라우드 컴퓨팅
  - 사물 인터넷



## 운영체제의 구조

- 커널과 인터페이스
  - 커널(엔진) : 운영체제의 핵심기능을 모아 놓은 것(프로세스 관리, 메모리 관리, 저장장치 관리)
  - 인터페이스(핸들, 브레이크, 계기판) : 커널에 사용자의 명령을 전달하고 실행결과를 사용자에게 알려주는 역할
  - 운영체제는 커널과 인터페이스를 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 가진 형태로 제작할 수 있음
  - 같은 커널이라도 다른 인터페이스가 장착되면 사용자에게 다른 운영체제로 보일 수 있다
    - 유닉스의 사용자 인터페이스는 shell => 근데 Mac Os도 유닉스 기반임
- 시스템 호출과 디바이스 드라이버
  - 시스템 호출 : 커널이 제공하는 시스템 관련 서비스를 모아놓은 것, 함수형태로 제공/ 응용 프로그램(사용자)과 커널의 인터페이스
    - 커널이 자신을 보호하기 위해 만든 인터페이스
    - 사용자나 응용 프로그램으로부터 자원에 직접 접근하는 것을 차단
    - 사용자 입장과 응용프로그램 입장
  - 드라이버 : 하드웨어와 커널의 인터페이스
    - 운영체제가 다양한 종류의 하드웨어를 사용할 수 있는 환경을 제공하려면 각 하드웨어에ㅐ 맞는 프로그램을 개발해야함 => 불가능
    - 하드웨어 제작자가 관련 소프트웨어를 만드는 것이 더 유리함(잘 아니까)
    - 커널은 입출력의 기본적인 부분만 제작, 소프트웨어(하드웨어의 특성을 반영한)가 커널이 실행될 때 함께 실행되도록 함
      - 이 소프트웨어가 드라이버임
      - 키보드, 마우스 등 단순한 하드웨어의 경우 그냥 연결만으로 작동/ 그래픽 카드, 프린터 같은 경우 드라이버 설치
- 커널의 구성(핵심기능의 구현 방법에 따라 3가지로 나뉜다)
  - 핵심 기능
    - 프로세스 관리 : 프로세스에 CPU를 분배하고 작업에 필요한 제반 환경을 제공
    - 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공
    - 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스 제공
    - 입출력 관리 : 필요한 입력과 출력 서비스 제공
    - 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경을 지원
  - 단일형 구조 커널 : 커널의 핵심 기능을 구현하는 모듈들의 구분 없이 하나로 구성
    - MS-DOS, VMS, 초기의 유닉스
    - 프로그램으로 치면 함수를 사용하지 않고 `main()`에다가 모든 기능을 구현한 형태
    - 장점
      - 모듈의 분리가 없어 모듈간 통신 비용이 줄어들어 효율적인 운영이 가능
      - 함수를 호출하는 오버헤드가 없어서 프로그램이 빨라지는 이치
    - 단점
      - 모든 모듈이 하나로 처리되어 버그나 오류처리가 어려움
      - 운영체제의 여러 기능이 연결되어 상호 의존성이 높기 때문에 기능상의 작은 결함이 => 전체로 확산
      - 다양한 환경의 시스템에 적용하기 어려움 => 수정이 어렵다 => 이식성이 낮다(다른 컴퓨터로)
      - 운영체제가 크고 복잡해질수록 단일형 구조의 운영체제를 구현하기 어려움
  - 계층형 구조 커널
  - 마이크로 구조 커널
- 가상머신



