

# 운영체제의 개요

- 운영체제의 필요성과 정의, 역할, 목표에 대한 이해

- 초창기부터 현재까지 운영체제의 발전과정

- 현대의 컴퓨팅 환경 파악

  

## 1. 운영체제 소개

- 일상속의 운영체제 : 윈도우, Mac OS, 유닉스, 리눅스, 임베디드 운영체제 등
- 운영체제의 필요성
  - 프로그래밍이 가능함 => 지속적으로 업데이트를 할 수 있다
  - 자원관리의 중재자 역할

- 정의 : 사용자에게 편리한 인터페이스 환경을 제공하고, 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어
- 역할
  - 자원관리 : 컴퓨터 자원을 응용프로그램에 적절히 나누어줌
  - 자원보호 
  - 하드웨어 인터페이스 제공 : 다양한 하드웨어를 일관된 방법으로 사용(장치 드라이버 = 하드웨어 인터페이스)
  - 사용자 인터페이스 제공(GUI)

- 목표
  - 효율성
    - 같은 자원 더 많은 일 처리/ 같은 작업량 적은 시간
  - 안정성
    - 응용 프로그램의 안전 문제
    - 하드웨어적 보안 문제
    - 결함 포용 기능(문제 발생 시 이전으로 복구)
  - 확장성
    - 플러그 앤드 플레이
  - 편리성
    - 편리성을 제공하지 않으면(GUI 등) 효율은 높아지지만 그러면 안됨



## 2. 운영체제의 역사

- 개요
  - 1940년대 : /진공관 사용
  - 1950년대 : 카드 리더, 라인 프린터 / 일괄 작업 시스템, 운영체제의 등장
  - 1960년대 초 : 키보드, 모니터 / 대화형 시스템
  - 1960년대 후 : C언어 / 다중 프로그래밍 기술 개발, 시분할 시스템
  - 1970년대 : PC / 개인용 컴퓨터, 분산 시스템
  - 1990년대 : 웹 / 클라이언트, 서버시스템
  - 2000년대 : 스마트폰 / P2P 시스템, 그리드 컴퓨팅, 클라우드 컴퓨팅, 사물 인터넷



- 초창기 컴퓨터(1940)
  - 애니악
  - 전선을 잭에 꼽아 회로를 연결하여 구성
  - 미사일 탄도 계산 목적
  - 주변장치가 없었음(모니터, 마우스, 키보드 등)
  - 진공관을 전선으로 연결한 것이 프로그램을 대신함
  - 하드와이어링 방식 : 전선을 연결하여 논리회로를 구성 => 만약 다른 계산을 하려면 전선을 다시 연결해야함

- 일괄 작업 시스템(1950)
  - IC칩(Integrated Circuit) : 진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 구현 -> 현대 컴퓨터의 시초
  - 중앙처리장치(메인메모리, CPU)는 존재, 입력장치(키보드)와 출력장치는 없었음(모니터)
  - 천공카드 리드를 입력장치, 라인 프린터를 출력장치로 사용
  - 천공카드 리더를 통한 프로그래밍 가능
  - 일괄작업 시스템(일괄처리 시스템) : 모든 작업을 한꺼번에 처리해야 하고, 프로그램 실행 중간에 데이터 입력 및 수정 불가능
  
- 대화형 시스템(1960 초)
  - 키보드와 모니터 등장 => 작업 중간에 사용자가 입력을 하거나 사용자에게 중간 결과값을 보여줄 수 있게됨
    - 일괄작업 시스템에서는 최종 결과만 볼 수 있고, 그 값을 바탕으로 천공카드를 새로 뚫어서 프로그래밍을 했었음
  - 진행 도중에 사용자로부터 입력을 받을 수 있고, 그 값에 따라 작업의 흐름을 바꾸는 것이 가능 => 대화형 시스템
  - 작업 시간 예측이 어려워짐 => 입력과 출력이 얼마만에 완료될지 예측하기 어렵고, 사용자의 반응시간 고려 불가능
  
- 시분할 시스템(1960 후)
  - 다중 프로그래밍 기술 : 하나의 CPU로 여러 작업을 동시에 실행하는 기술, 일괄 작업에 비해 효율적
  - 시간 분할을 통해 다중 프로그래밍을 구현
    - 시스템에서 CPU 사용 시간을 아주 잘게 쪼개어 여러 작업에 나누어 줌
    - 이때 잘게 나누니 시간 한 조각을 타임 슬라이스(타임 퀀텀)이라고 함
  - 여러 작업을 동시에 처리하기 위한 추가 작업이 필요한 것이 단점
    - 그래서 중요한 작업의 경우(미사일 제어, 원자력 제어 등) 실시간 시스템을 사용
    - 실시간 시스템 : 특정 시스템에서 일정 시간 안에 작업이 처리되도록 보장하는 것
  - 다중 사용자 시스템 : 한 사람이 여러개의 작업을 할 수 있다 = 여러 사람이 동시에 작업할 수 있다.
    - C언어로 개발된 유닉스 : 멀티프로그래밍과 다중 사용자를 지원하는 운영체제
  
- 분산 시스템(1970)
  - 개인용 컴퓨터의 등장 : 스티브 잡스가 최초로 발표
    - 운영체제로 매킨토시와 MS-DOS가 널리 사용됨
  - 서로 호환되지 않는 LAN(local area network)들을 하나로 묶어 ARPAnet을 제작
  - TCP/IP  정의
  - 분산 시스템 : 작은 컴퓨터를 여러대 묶어 대형 컴퓨터의 기능에 버금가는 시스템을 만든 것
    - 네트워크상에 분산되어 있는 여러 컴퓨터로 작업을 처리하고 그 결과를 상호 교환하도록 구성한 시스템
  
- 클라이언트/서버 시스템(1990~현재)
  - 분산 시스템의 문제 : 참가하는 모든 컴퓨터가 동일한 지위이기 때문에 컴퓨터가 고장나거나 추가되면 작업을 분배하고 결과를 모으기 어려움
  - 클라이언트/서버 시스템 : 작업을 요청하는 클라이언트와 거기에 응답하여 요청받은 작업을 처리하는 서버의 이중구조
    - 서버 과부하가 문제
  
- P2P 시스템(2000~현재)
  - P2P(peer-to-peer) : 서버 과부하를 해결하기위한 시스템
    - peer는 말단 노드, 사용자의 컴퓨터를 가르킨다
    - P2P는 서버를 거치지 않고 사용자와 사용자를 직접 연결한다는 의미
    - 시스템에서 파일 검색만 담당 => 사용자간 파일 전송
  - 메신저, 파일공유 등
  
- 기타 컴퓨팅 환경(2000 ~ 현재)

  - 그리드 컴퓨팅
    - 분산 시스템의 한 분야
    - 서로 다른 기종의 컴퓨터들을 묶어 대용량의 컴퓨터 풀을 구성 => 대용량 연산을 수행할 수 있는 환경 조성

  - 클라우드 컴퓨팅
    - ec2서버
  - 사물 인터넷
    - iot



## 3. 운영체제의 구조

- 커널과 인터페이스
  - 커널(엔진) : 운영체제의 핵심기능을 모아 놓은 것(프로세스 관리, 메모리 관리, 저장장치 관리)
  - 인터페이스(핸들, 브레이크, 계기판) : 커널에 사용자의 명령을 전달하고 실행결과를 사용자에게 알려주는 역할
  - 운영체제는 커널과 인터페이스를 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 가진 형태로 제작할 수 있음
  - 같은 커널이라도 다른 인터페이스가 장착되면 사용자에게 다른 운영체제로 보일 수 있다
    - 유닉스의 사용자 인터페이스는 shell => 근데 Mac Os도 유닉스 기반임
- 시스템 호출과 디바이스 드라이버
  - 시스템 호출 : 커널이 제공하는 시스템 관련 서비스를 모아놓은 것, 함수형태로 제공/ 응용 프로그램(사용자)과 커널의 인터페이스
    - 커널이 자신을 보호하기 위해 만든 인터페이스
    - 사용자나 응용 프로그램으로부터 자원에 직접 접근하는 것을 차단
    - 사용자 입장과 응용프로그램 입장
  - 드라이버 : 하드웨어와 커널의 인터페이스
    - 운영체제가 다양한 종류의 하드웨어를 사용할 수 있는 환경을 제공하려면 각 하드웨어에 맞는 프로그램을 개발해야함 => 불가능
    - 하드웨어 제작자가 관련 소프트웨어를 만드는 것이 더 유리함(잘 아니까)
    - 커널은 입출력의 기본적인 부분만 제작, 소프트웨어(하드웨어의 특성을 반영한)가 커널이 실행될 때 함께 실행되도록 함
      - 이 소프트웨어가 드라이버임
      - 키보드, 마우스 등 단순한 하드웨어의 경우 그냥 연결만으로 작동/ 그래픽 카드, 프린터 같은 경우 드라이버 설치
- 커널의 구성(핵심기능의 구현 방법에 따라 3가지로 나뉜다)
  - 핵심 기능
    - 프로세스 관리 : 프로세스에 CPU를 분배하고 작업에 필요한 제반 환경을 제공
    - 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공
    - 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스 제공
    - 입출력 관리 : 필요한 입력과 출력 서비스 제공
    - 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경을 지원
  - 단일형 구조 커널 : 커널의 핵심 기능을 구현하는 모듈들의 구분 없이 하나로 구성
    - MS-DOS, VMS, 초기의 유닉스
    - 프로그램으로 치면 함수를 사용하지 않고 `main()`에다가 모든 기능을 구현한 형태
    - 장점
      - 모듈의 분리가 없어 모듈간 통신 비용이 줄어들어 효율적인 운영이 가능
      - 함수를 호출하는 오버헤드가 없어서 프로그램이 빨라지는 이치
    - 단점
      - 모든 모듈이 하나로 처리되어 버그나 오류처리가 어려움
      - 운영체제의 여러 기능이 연결되어 상호 의존성이 높기 때문에 기능상의 작은 결함이 => 전체로 확산
      - 다양한 환경의 시스템에 적용하기 어려움 => 수정이 어렵다 => 이식성이 낮다(다른 컴퓨터로)
      - 운영체제가 크고 복잡해질수록 단일형 구조의 운영체제를 구현하기 어려움
  - 계층형 구조 커널
    - 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만든 것
    - 계층 간의 통신을 통해 운영체제를 구현하는 방식
    - 오류가 나면 => 커널 전체를 수정하는 것이 아니라, 오류가 난 계층만 수정하면 됨
    - 오늘날의 운영체제 대부분이 이 구조로 이루어져있음
  - 마이크로 구조 커널
    - 커널의 크기가 계속 커지고, 필요한 하드웨어의 용량이 늘어남 => 커널 소스가 방대해지면서 오류를 잡기 어려워짐
    - 계층형 구조 접근 방식과 반대로 개발된 커널이 마이크로 구조커널
    - 가장 기본적인 기능만 제공(프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등)
    - 운영체제의 많은 부분이 사용자 영역에 구현되어 있음
    - 각 모듈이 독립적으로 작동해서 => 하나가 멈춰도 => 전체가 멈추지는 않음
- 가상머신
  - 응용 프로그램과 운영체제의 호환이 맞지 않을 때 연결자 역할



## 4. 요약

- 정의 : 사용자에게 편리한 인터페이스 환경을 제공하고, 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트웨어

- 역활과 목표

​	자원관리 => 효율성

​	자원보호 => 안정성

​	하드웨어 인터페이스 => 확장성

​	사용자 인터페이스 => 편리성

- 구성

​	커널 : 운영체제의 핵심 기능을 모아놓은 것 

​	인터페이스 : 응용 프로그램에게 커널의 명령어를 전달하고 결과를 응용 프로그램에게 돌려주는 역할



